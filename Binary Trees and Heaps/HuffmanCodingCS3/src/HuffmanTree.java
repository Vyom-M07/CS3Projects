import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Scanner;

public class HuffmanTree {

	PriorityQueue<Node> queue = new PriorityQueue<Node>();
	private HashMap<Integer, String> map = new HashMap<Integer, String>();

	/**
	 * @param counts
	 * 
	 *               This method will construct the Huffman tree using the supplied
	 *               array of character frequencies, where counts [i] is the number
	 *               of occurrences of the character with integer (decimal) value i.
	 *               For example, counts [32] is the number of spaces.
	 */
	HuffmanTree(int[] counts) {
		// index number is the ascii value of character
		// arr[index number] = the freq of that ascii value

		for (int i = 0; i < counts.length; i++) {
			if (counts[i] != 0) {
				Node node = new Node((char) i, counts[i]);
				queue.add(node);
			}
		}

		queue.add(new Node((char) 256, 1));

		while (queue.size() > 1) {
			Node n1 = queue.poll();
			Node n2 = queue.poll();

			Node newRoot = new Node(n1.getFrequency() + n2.getFrequency());
			newRoot.left = n2;
			newRoot.right = n1;
			queue.offer(newRoot);
		}
	}

	public HashMap<Integer, String> createMap(HashMap<Integer, String> map) {
		String str = "";
		traverseHelper(queue.peek(), str);
		return map;
	}

	void traverseHelper(Node root, String str) {

		if (root != null) {

			if (root.left == null && root.right == null) {
				map.put((int) root.getVal(), str.toString());
				return;
			}
			traverseHelper(root.left, str + "0");

			traverseHelper(root.right, str + "1");

		}

	}

	/**
	 * @param filename This method should write your encoding tree to the given file
	 *                 in a standard format, using the naming conventions provided
	 *                 later.
	 * 
	 *                 Give relative path
	 * @throws FileNotFoundException
	 */
	void write(String filename) throws FileNotFoundException {
		createMap(map);
		File myFile = null;
		try {
			// System.out.println("C:\\Users\\OPBos\\eclipse-workspace\\HuffmanCodingCS3\\src\\"
			// +
			// filename.substring(0, filename.indexOf('.')) + ".code");
			myFile = new File("C:\\Users\\OPBos\\eclipse-workspace\\HuffmanCodingCS3\\src\\"
					+ filename.substring(0, filename.indexOf('.')) + ".code");
			if (myFile.createNewFile()) {
				System.out.println("File created: " + myFile.getName());
			} else {
				System.out.println("File already exists.");
			}

		} catch (IOException e) {
			System.out.println("An error occurred.");
			e.printStackTrace();
		}

		// System.out.println(map.toString());
		PrintWriter writer = new PrintWriter(myFile);
		// map.forEach((n, m) -> System.out.println(n + "\n" + m));
		map.forEach((key, value) -> writer.write(key + "\n" + value + "\n"));
		writer.close();

	}

	/**
	 * @param out
	 * @param filename
	 * 
	 *                 This method will write a compressed binary file using the
	 *                 Huffman codes generated by the Huffman tree. It will write
	 *                 the Huffman code for each character, bit by bit, using
	 *                 BitOuputStream .
	 * 
	 *                 Use relative path
	 */
	void encode(BitOutputStream out, String filename) {

		String prePath = "C:\\Users\\OPBos\\eclipse-workspace\\HuffmanCodingCS3\\src\\";
		File myFile = null;
		try {
			System.out.println(prePath + filename.substring(0, filename.indexOf('.')) + ".short");
			myFile = new File(prePath + filename.substring(0, filename.indexOf('.')) + ".short");
			if (myFile.createNewFile()) {
				System.out.println("File created: " + myFile.getName());
			} else {
				System.out.println("File already exists.");
			}

		} catch (IOException e) {
			System.out.println("An error occurred.");
			e.printStackTrace();
		}

		// bitoutput writes to .short file
		try {
			FileReader reader = new FileReader(prePath + filename); // read from origial txt file
			int ch;
			while ((ch = reader.read()) != -1) {

				String str = map.get(ch); // EX: str is 00 for 'p'

				for (int i = 0; i < str.length(); i++) {
		//			System.out.print(Integer.parseInt(str.charAt(i) + ""));
					out.writeBit(Integer.parseInt(str.charAt(i) + ""));
				}
	//			System.out.println();
			}
			String str = map.get(256); // for Psuedo-EOF character
			for (int i = 0; i < str.length(); i++) {
		//		System.out.print(Integer.parseInt(str.charAt(i) + ""));
				out.writeBit(Integer.parseInt(str.charAt(i) + ""));
			}
			out.close();
			reader.close();
		} catch (IOException e) {
			e.printStackTrace();

		}

	}

	Node root = new Node(-1);

	// .code file supplied in parameter
	HuffmanTree(String codeFile) throws FileNotFoundException {

		File myFile = new File("C:\\Users\\OPBos\\eclipse-workspace\\HuffmanCodingCS3\\src\\" + codeFile);
		Scanner sc = new Scanner(myFile);

		while (sc.hasNext()) {
			int n = Integer.parseInt(sc.nextLine()); // gets ascii-value of character (char.val in node class)
			String code = sc.nextLine(); // gets huffman path for the character
			Node traverse = root;
			for (int i = 0; i < code.length(); i++) {

				if (code.charAt(i) == '0' && i != code.length() - 1) {

					if (traverse.left == null) {
						Node node = new Node(-1);
						traverse.left = node;
						traverse = node;
						// System.out.println("stuck inside 1");
					} else {
						traverse = traverse.left;
					}

				} else if (code.charAt(i) == '0') {
					traverse.left = new Node((char) n, -1);
					// System.out.println("stuck inside 2");
				} else if (code.charAt(i) == '1' && i != code.length() - 1) {

					if (traverse.right == null) {
						Node node = new Node(-1);
						traverse.right = node;
						traverse = traverse.right;
						// System.out.println("stuck inside 3");
					} else {
						traverse = traverse.right;
					}

				} else if (code.charAt(i) == '1') {
					traverse.right = new Node((char) n, -1);
					// System.out.println("stuck inside 4");

				}

			}

		}

	}

	// BitInputStream in -> takes in the .short file when instantiating
	// outFile = the .new file
	void decode(BitInputStream in, String outFile) throws FileNotFoundException {

		String prePath = "C:\\Users\\OPBos\\eclipse-workspace\\HuffmanCodingCS3\\src\\";
		File myFile = null;

		try {
			System.out.println(prePath + outFile);
			myFile = new File(prePath + outFile);
			if (myFile.createNewFile()) {
				System.out.println("File created: " + myFile.getName());
			} else {
				System.out.println("File already exists.");
			}

		} catch (IOException e) {
			System.out.println("An error occurred.");
			e.printStackTrace();
		}

		PrintWriter writer = new PrintWriter(myFile);
		Node t = root;
		int read;
		while (true) {
		read = in.readBit();	
		
		if(read == 0) {
			t = t.left;
		} else {
			t = t.right;
		}
		
		if(t.getVal() == 256) {
			break;
		}
		
		if (t.left == null && t.right == null) {
			writer.write(t.getVal());
//			System.out.println(t.getVal());
			t = root;
			}
		
	}
		writer.close();
		in.close();
		
		
	}
}
